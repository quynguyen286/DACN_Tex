\subsection{Thiết kế Kiến trúc Hệ thống}
\subsubsection{Kiến trúc Phân lớp (Layered Architecture)}

Kiến trúc hệ thống được thiết kế theo mô hình Phân lớp (Layered Architecture) kết hợp với hướng dịch vụ (Service-oriented). Việc phân chia này giúp tách biệt các mối quan tâm (Separation of Concerns), dễ dàng bảo trì và mở rộng độc lập từng thành phần.

Sơ đồ dưới đây minh họa các tầng logic và luồng dữ liệu trong hệ thống:

\begin{figure}[H]
    \centering
    % Đổi tên file ảnh kiến trúc của bạn vào đây
    \includegraphics[width=0.75\textwidth]{img/architecture.png}
    \caption{Sơ đồ Kiến trúc Phân lớp của Hệ thống}
    \label{fig:system_architecture}
\end{figure}

Hệ thống được tổ chức thành 6 tầng chính và 1 module bảo mật xuyên suốt:

\begin{itemize}[leftmargin=*]
    \item \textbf{Presentation Layer (Tầng Giao diện):}
    Là điểm tiếp xúc với người dùng cuối (System Admin). Tầng này gửi các yêu cầu HTTP đến hệ thống thông qua giao diện Web Admin để thực hiện các tác vụ quản lý.

    \item \textbf{Integration Layer (Tầng Tích hợp):}
    Đóng vai trò là cổng vào duy nhất (Entry Point) và điều phối luồng dữ liệu, bao gồm 2 thành phần:
    \begin{itemize}
        \item \textit{API Gateway:} Tiếp nhận và định tuyến các yêu cầu RESTful từ Web Admin xuống các dịch vụ nghiệp vụ tương ứng.
        \item \textit{RabbitMQ Message Queue:} Đóng vai trò Broker trung gian, tiếp nhận hàng loạt dữ liệu bất đồng bộ từ các thiết bị IoT (Sensors/ESP32), giúp giảm tải cho hệ thống xử lý chính (Decoupling).
    \end{itemize}

    \item \textbf{Business Layer (Tầng Nghiệp vụ):}
    Nơi chứa toàn bộ logic xử lý của hệ thống:
    \begin{itemize}
        \item \textit{User \& Farm Management:} Xử lý các logic về quản lý người dùng, nông trại, và cấu hình thiết bị.
        \item \textit{IoT Data Processor:} Service chuyên biệt (Worker) để tiêu thụ dữ liệu từ RabbitMQ, xử lý tính toán, cảnh báo và chuẩn hóa dữ liệu trước khi lưu trữ.
    \end{itemize}

    \item \textbf{Persistence Layer (Tầng Truy xuất Dữ liệu):}
    Cung cấp lớp trừu tượng hóa (Abstraction) để giao tiếp với cơ sở dữ liệu (Data Access Component), giúp tách biệt logic nghiệp vụ khỏi các câu lệnh truy vấn SQL cụ thể.

    \item \textbf{Database Layer (Tầng Dữ liệu):}
    Sử dụng chiến lược lưu trữ đa mô hình (Polyglot Persistence):
    \begin{itemize}
        \item \textit{PostgreSQL:} Lưu trữ dữ liệu quan hệ có cấu trúc (Users, Farms, Devices).
        \item \textit{TimescaleDB:} Cơ sở dữ liệu chuyên dụng cho Time-series để lưu trữ hàng triệu bản ghi nhật ký cảm biến (Telemetries) với hiệu năng cao.
        \item \textit{AWS S3:} Lưu trữ các file tĩnh (hình ảnh cây trồng, log files).
    \end{itemize}

    \item \textbf{Physical Layer (Tầng Vật lý):}
    Bao gồm các thiết bị phần cứng (ESP32, Sensors, Actuators) thu thập dữ liệu môi trường và thực thi các lệnh điều khiển từ server.
\end{itemize}

\paragraph{Module Bảo mật (Cross-cutting Concern):}
Thành phần \textit{Account Control Privileges} bao quát từ tầng Integration xuống tầng Business, đảm bảo mọi yêu cầu đi qua API Gateway đều được xác thực (Authentication) và phân quyền (Authorization) chặt chẽ trước khi được xử lý.

\subsubsection{Kiến trúc Triển khai (Deployment Architecture)}

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{img/deploy_architecture.png}
    \caption{Deployment Diagram}
    \label{fig:deployment_diagram_firmware}
\end{figure}

Sơ đồ triển khai (Hình \ref{fig:deployment_diagram_firmware}) mô tả cách thức ánh xạ các thành phần phần mềm vào hạ tầng phần cứng vật lý và môi trường mạng. Hệ thống được triển khai theo mô hình tập trung (Centralized Cloud Architecture) kết hợp với các thiết bị biên (Edge Devices).

Các thành phần triển khai chính bao gồm:

\begin{itemize}
    \item \textbf{Field Node (Nút thiết bị tại nông trại):}
    \begin{itemize}
        \item \textit{Vi điều khiển:} Sử dụng ESP32-S3 chạy Firmware dựa trên hệ điều hành thời gian thực FreeRTOS, đảm bảo khả năng xử lý đa nhiệm (đọc cảm biến và gửi mạng song song).
        \item \textit{Kết nối vật lý:} Các cảm biến (DHT20, Soil Moisture) và camera (OV2640) được kết nối trực tiếp qua các giao tiếp I2C, Analog và DVP. Các thiết bị chấp hành (Máy bơm, Quạt) được điều khiển qua Module Relay.
    \end{itemize}

    \item \textbf{Server Infrastructure (Hạ tầng Máy chủ):}
    Toàn bộ hệ thống Backend được đóng gói và triển khai trên nền tảng \textbf{Docker}, giúp đảm bảo tính nhất quán giữa môi trường phát triển và vận hành (Production). Hạ tầng bao gồm các Container chính:
    \begin{itemize}
        \item \textit{Nginx Reverse Proxy:} Đóng vai trò lớp bảo mật đầu tiên, tiếp nhận mọi yêu cầu từ Internet (Port 80/443), chấm dứt SSL (SSL Termination) và điều phối traffic vào các dịch vụ bên trong.
        \item \textit{Application Container:} Chạy NestJS Backend để xử lý API và logic nghiệp vụ.
        \item \textit{Message Broker Container:} Chạy RabbitMQ để tiếp nhận dữ liệu IoT qua giao thức MQTT.
        \item \textit{Database Cluster:} Chạy PostgreSQL tích hợp Extension TimescaleDB, phục vụ lưu trữ dữ liệu lai (Hybrid Storage).
    \end{itemize}

    \item \textbf{Cơ chế Giao tiếp (Communication Protocols):}
    \begin{itemize}
        \item \textit{Device - Server:} Sử dụng giao thức \textbf{MQTT} qua WiFi/4G để truyền tải dữ liệu cảm biến (nhẹ, thời gian thực) và giao thức \textbf{HTTP} để tải lên hình ảnh (dữ liệu lớn).
        \item \textit{Client - Server:} Web Admin giao tiếp với hệ thống thông qua \textbf{HTTPS} (bảo mật) và \textbf{WebSocket} (để nhận cập nhật dữ liệu thời gian thực trên Dashboard).
    \end{itemize}
\end{itemize}

\paragraph{Đánh đổi kiến trúc và Rủi ro}
Mặc dù kiến trúc phân lớp mang lại nhiều lợi ích về tính mô-đun và khả năng mở rộng, việc triển khai đòi hỏi đánh đổi về độ phức tạp. Nhóm đã cân nhắc kỹ lưỡng giữa lợi ích dài hạn (scalability, maintainability) và chi phí triển khai ban đầu. Chi tiết về phân tích đánh đổi được trình bày ở phần riêng sau.

\subsection{Phân tích đánh đổi kiến trúc và Quản lý rủi ro}

Việc lựa chọn kiến trúc phân lớp (Layered Architecture) kết hợp với các thành phần Microservices (như Worker tách rời) và Polyglot Persistence (đa cơ sở dữ liệu) mang lại khả năng mở rộng lớn, nhưng đồng thời cũng đặt ra bài toán về độ phức tạp khi triển khai. Dưới đây là phân tích chi tiết các đánh đổi (Trade-offs) và biện pháp giảm thiểu rủi ro của nhóm.

\subsection{Tại sao không chọn kiến trúc Monolithic đơn giản?}
Mặc dù kiến trúc nguyên khối (Monolithic) đơn giản, dễ triển khai (chỉ cần 1 Server + 1 DB), nhưng nhóm quyết định chọn kiến trúc phân tán hướng dịch vụ vì các lý do sau:

\begin{itemize}
    \item \textbf{Khả năng mở rộng độc lập (Scalability):} Module xử lý dữ liệu IoT (Worker) cần tài nguyên CPU cao để chạy thuật toán RFE, trong khi Web Server phục vụ API chỉ cần ít tài nguyên. Việc tách rời giúp nhóm có thể nhân bản (scale) Worker mà không ảnh hưởng đến Web API.
    \item \textbf{Phù hợp làm việc nhóm:} Với 3 thành viên (Firmware, Backend, Frontend/AI), kiến trúc phân lớp giúp phân chia ranh giới công việc rõ ràng (Decoupling), tránh việc code chồng chéo (Merge conflicts) quá nhiều.
    \item \textbf{Chuẩn bị cho Đồ án Tốt nghiệp:} Đồ án chuyên ngành là bước đệm. Việc xây dựng khung kiến trúc chuẩn ngay từ đầu giúp giai đoạn 2 chỉ cần tập trung phát triển tính năng mà không phải đập đi xây lại (Refactoring).
\end{itemize}

\subsection{Đánh đổi kỹ thuật}
\begin{table}[H]
    \centering
    \caption{Bảng phân tích đánh đổi khi lựa chọn công nghệ}
    \label{tab:tradeoff}
    \renewcommand{\arraystretch}{1.4}

    \begin{tabularx}{\textwidth}{|>{\raggedright\arraybackslash}p{5cm}|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X|}
    \hline
    \textbf{Quyết định kiến trúc} & \textbf{Lợi ích (Pros)} & \textbf{Cái giá phải trả (Cons)} \\
    \hline

    \textbf{Sử dụng Message Queue (RabbitMQ)} &
    Đảm bảo tính bất đồng bộ, không mất dữ liệu khi Server quá tải (Back-pressure), giảm độ trễ phản hồi API. &
    Tăng độ phức tạp vận hành. Phải quản lý thêm một service Broker, khó debug luồng dữ liệu hơn so với gọi HTTP trực tiếp. \\
    \hline

    \textbf{Polyglot Persistence (TimescaleDB + PostgreSQL)} &
    Tối ưu hóa truy vấn chuỗi thời gian (nhanh hơn 10x), nén dữ liệu tốt. &
    Phải quản lý schema phức tạp hơn. Cần kiến thức chuyên sâu về cả Relational và Time-series DB. \\
    \hline

    \textbf{Containerization (Docker)} &
    Môi trường đồng nhất giữa Dev và Prod, dễ dàng triển khai. &
    Tốn tài nguyên hệ thống (RAM/CPU) hơn so với chạy Native trên máy ảo đơn giản. \\
    \hline

    \end{tabularx}
\end{table}

\subsection{Rủi ro và Chiến lược giảm thiểu}
Với quy mô của một đồ án sinh viên, việc vận hành hệ thống phức tạp tiềm ẩn nhiều rủi ro. Nhóm đã xác định và có phương án cụ thể:

\begin{description}
    \item[Rủi ro 1: Quá tải về mặt triển khai (DevOps Overhead)] \hfill \\
    Việc cấu hình Nginx, Docker, RabbitMQ tốn nhiều thời gian. \\
    $\rightarrow$ \textbf{Giải pháp:} Nhóm sử dụng \texttt{Docker Compose} để đóng gói toàn bộ môi trường (Infrastructure as Code). Chỉ cần 1 lệnh \texttt{docker-compose up} là dựng được toàn bộ hệ thống, giúp thành viên phát triển Frontend/Firmware không cần cài đặt phức tạp.

    \item[Rủi ro 2: Khó kiểm soát lỗi (Debugging)] \hfill \\
    Luồng dữ liệu đi qua nhiều trạm (MQTT $\rightarrow$ RabbitMQ $\rightarrow$ NestJS $\rightarrow$ DB) khiến việc tìm nguyên nhân lỗi khó khăn. \\
    $\rightarrow$ \textbf{Giải pháp:} Nhóm xây dựng cơ chế \textbf{Centralized Logging} đơn giản, ghi log tập trung tại mỗi điểm nút quan trọng để truy vết (Traceability).
\end{description}

\textbf{Kết luận:} Kiến trúc này tuy có độ phức tạp cao hơn mức trung bình của một đồ án sinh viên, nhưng là sự đầu tư cần thiết để giải quyết bài toán "Real-time" và "Big Data" của Nông nghiệp thông minh, đồng thời tiệm cận với quy chuẩn thực tế của doanh nghiệp.