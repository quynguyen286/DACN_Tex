\subsection{Kiến trúc hệ thống và Công nghệ nền tảng}
\subsubsection{Kiến trúc tổng thể}
\indent Hệ thống Xanh Market được thiết kế theo mô hình kiến trúc phân lớp (Layered Architecture) kết hợp với hướng dịch vụ (Service-oriented Architecture), đảm bảo tính mô-đun hóa cao và khả năng mở rộng độc lập từng thành phần. Hệ thống được tổ chức thành 5 tầng logic chính:

\begin{itemize}
    \item \textbf{Lớp thiết bị (Device Layer):} Là tầng thấp nhất bao gồm các thiết bị IoT triển khai tại hiện trường nông trại:
    \begin{itemize}
        \item \textit{Trạm quan trắc (IoT Gateway):} Sử dụng ESP32 làm bộ xử lý trung tâm, tích hợp các cảm biến môi trường (DHT11, DS18B20, Soil Moisture, Light Sensor) và module truyền thông (WiFi, RS485).
        \item \textit{Thiết bị chấp hành (Actuators):} Bao gồm hệ thống tưới tiêu tự động với van điện từ, máy bơm và các cơ cấu điều khiển khác.
        \item \textit{Giao thức truyền thông:} Sử dụng MQTT qua WiFi để truyền dữ liệu thời gian thực và HTTP cho tải lên hình ảnh/video.
    \end{itemize}

    \item \textbf{Lớp tích hợp (Integration Layer):} Đóng vai trò là cầu nối giữa thiết bị và hệ thống backend:
    \begin{itemize}
        \item \textit{API Gateway:} Điểm vào duy nhất cho tất cả các yêu cầu từ phía client, thực hiện xác thực, định tuyến và cân bằng tải.
        \item \textit{Message Broker (RabbitMQ):} Hệ thống hàng đợi thông điệp để xử lý dữ liệu IoT bất đồng bộ, đảm bảo tính reliable và decoupling giữa producer và consumer.
        \item \textit{Data Ingestion Service:} Tiếp nhận và tiền xử lý dữ liệu từ MQTT broker trước khi lưu trữ.
    \end{itemize}

    \item \textbf{Lớp nghiệp vụ (Business Layer):} Chứa toàn bộ logic xử lý cốt lõi của hệ thống:
    \begin{itemize}
        \item \textit{User Management Service:} Quản lý tài khoản người dùng, phân quyền và xác thực.
        \item \textit{Farm Management Service:} Xử lý logic quản lý nông trại, thiết bị và cấu hình giám sát.
        \item \textit{IoT Data Processor:} Service chuyên biệt để xử lý dữ liệu cảm biến, áp dụng thuật toán phát hiện lỗi (RFE) và tạo cảnh báo.
        \item \textit{Analytics Engine:} Phân tích dữ liệu lịch sử để đưa ra insights và khuyến nghị cho người dùng.
    \end{itemize}

    \item \textbf{Lớp dữ liệu (Data Layer):} Quản lý lưu trữ và truy xuất dữ liệu với chiến lược đa mô hình:
    \begin{itemize}
        \item \textit{PostgreSQL:} Cơ sở dữ liệu quan hệ lưu trữ thông tin cấu trúc (users, farms, devices, configurations).
        \item \textit{TimescaleDB:} Cơ sở dữ liệu chuỗi thời gian chuyên dụng cho dữ liệu cảm biến với hiệu năng truy vấn cao.
        \item \textit{AWS S3:} Lưu trữ file tĩnh như hình ảnh, log files và báo cáo.
    \end{itemize}

    \item \textbf{Lớp ứng dụng (Application Layer):} Giao diện người dùng cuối:
    \begin{itemize}
        \item \textit{Web Admin Portal:} Giao diện quản trị chính với dashboard thời gian thực, biểu đồ trực quan hóa dữ liệu và công cụ quản lý hệ thống.
        \item \textit{RESTful APIs:} Cung cấp các endpoint chuẩn cho tích hợp với hệ thống bên thứ ba.
        \item \textit{Real-time Notifications:} Hệ thống cảnh báo tức thì qua WebSocket cho các sự kiện quan trọng.
    \end{itemize}
\end{itemize}

Kiến trúc này đảm bảo tính linh hoạt cao với khả năng mở rộng ngang (horizontal scaling) thông qua containerization (Docker) và orchestration tự động. Mô hình phân tán giúp hệ thống chịu tải tốt với hàng trăm thiết bị IoT đồng thời, đồng thời đảm bảo tính bảo mật với cơ chế xác thực đa lớp và mã hóa dữ liệu.

\subsubsection{Nền tảng ứng dụng}
\indent Hệ thống sử dụng giao diện Web Admin làm nền tảng chính cho việc quản trị và giám sát. Thiết kế web-based mang lại các ưu điểm sau:
\begin{itemize}
    \item \textbf{Truy cập đa nền tảng:} Web Admin có thể được truy cập từ bất kỳ thiết bị nào có trình duyệt web hiện đại (desktop, laptop, tablet), không yêu cầu cài đặt phần mềm đặc biệt.
    \item \textbf{Định danh và xác thực:} Sử dụng cơ chế đăng nhập dựa trên tài khoản quản trị viên với phân quyền chi tiết (Role-Based Access Control), đảm bảo tính bảo mật cao.
    \item \textbf{Thông báo thời gian thực:} Hệ thống tích hợp WebSocket để gửi cảnh báo và cập nhật dữ liệu thời gian thực trực tiếp trên giao diện web.
    \item \textbf{Công nghệ phát triển:} Giao diện được xây dựng bằng ReactJS với Vite, kết hợp với các thư viện trực quan hóa dữ liệu như Chart.js để tạo dashboard tương tác.
\end{itemize}

\subsubsection{Hạ tầng Backend và Quy trình DevOps}
\indent Hệ thống Backend được xây dựng trên nền tảng điện toán đám mây riêng (Private Cloud) tại phòng thí nghiệm HPC Lab để đảm bảo tính bảo mật và chủ quyền dữ liệu. Quy trình triển khai áp dụng các tiêu chuẩn công nghiệp:
\begin{itemize}
    \item \textbf{Ảo hóa và Container hóa:} Sử dụng Docker để đóng gói các dịch vụ, đảm bảo môi trường vận hành đồng nhất giữa phát triển và sản xuất.
    \item \textbf{CI/CD Pipeline:} Tích hợp quy trình Tích hợp liên tục và Triển khai liên tục (CI/CD) để tự động hóa việc cập nhật phần mềm.
    \item \textbf{Kiểm soát chất lượng mã nguồn:} Sử dụng SonarQube để tự động quét và phân tích mã nguồn, phát hiện các lỗ hổng bảo mật và đảm bảo chất lượng code trước khi triển khai.
    \item \textbf{Giám sát hệ thống (Monitoring):} Sử dụng bộ công cụ Grafana và Prometheus để theo dõi hiệu năng server, tài nguyên hệ thống (CPU, RAM, Disk) và trạng thái các dịch vụ theo thời gian thực.
\end{itemize}

\subsection{Giao thức công nghiệp}
\indent Để khắc phục các nhược điểm về nhiễu tín hiệu và suy hao đường truyền của các cảm biến Analog truyền thống trong môi trường thực tế, hệ thống sử dụng chuẩn giao tiếp công nghiệp dựa trên sự kết hợp giữa RS485 (Lớp vật lý) và Modbus RTU (Lớp giao thức).
\subsubsection{Chuẩn vật lý RS485 (Physical Layer)}
\indent RS485 (Recommended Standard 485) là chuẩn truyền thông nối tiếp vi sai (differential signaling), được thiết kế chuyên dụng cho các môi trường công nghiệp có nhiều nhiễu điện từ.
\begin{itemize}
    \item \textbf{Cơ chế hoạt động:} Khác với chuẩn RS232 hay tín hiệu Analog (so sánh điện áp với dây đất - GND), RS485 sử dụng hai dây tín hiệu A và B xoắn lại với nhau (Twisted pair). Giá trị logic được xác định bằng hiệu điện thế giữa hai dây:
    $$V_{diff} = V_A - V_B$$
    \begin{itemize}
        \item Logic 1: $V_A - V_B > 200mV$
        \item Logic 0: $V_A - V_B < -200mV$
    \end{itemize} 
    \item \textbf{Khả năng chống nhiễu (Noise Immunity):} Đây là đặc tính quan trọng nhất. Khi có nhiễu điện từ tác động lên đường dây, nó sẽ tác động đồng thời lên cả dây A và dây B với biên độ như nhau. Vì bộ thu chỉ quan tâm đến hiệu số điện áp $(V_A + V_{noise}) - (V_B + V_{noise}) = V_A - V_B$, nên thành phần nhiễu bị triệt tiêu hoàn toàn.
\end{itemize}

\subsubsection{Giao thức Modbus RTU (Data Link Layer)}
\indent Modbus RTU là một giao thức dạng Master-Slave hoạt động trên nền tảng vật lý RS485. Dữ liệu được mã hóa dưới dạng nhị phân nhỏ gọn để tối ưu tốc độ.
\begin{itemize}
    \item \textbf{Cấu trúc gói tin:} Mỗi gói tin bao gồm Địa chỉ Slave, Mã hàm (Function Code), Dữ liệu và mã kiểm lỗi CRC.
    \item \textbf{Độ tin cậy dữ liệu (Data Integrity):} Modbus RTU sử dụng cơ chế kiểm tra lỗi CRC-16 (Cyclic Redundancy Check). Khi thiết bị biên (ESP32) nhận được gói tin, nó sẽ tính toán lại mã CRC và so sánh với mã nhận được. Nếu không trùng khớp (do nhiễu đường truyền làm sai lệch bit), gói tin sẽ bị hủy bỏ ngay lập tức thay vì nhận sai giá trị. Điều này đảm bảo dữ liệu đầu vào cho thuật toán luôn chính xác.
\end{itemize}

\subsubsection{Lý do lựa chọn RS485/Modbus thay vì Analog}
\indent Cảm biến Analog phụ thuộc vào bộ đọc ADC của ESP32, mà ADC của ESP32 nổi tiếng là có độ nhiễu cao và không tuyến tính. Cảm biến Modbus thực hiện chuyển đổi số (ADC) ngay tại đầu dò với chip chuyên dụng, sau đó gửi dữ liệu số về. Điều này giúp loại bỏ hoàn toàn sai số do đường dây và do bộ vi điều khiển, đảm bảo dữ liệu đầu vào cho thuật toán RFE là chính xác nhất
\indent Việc chuyển đổi từ cảm biến Analog (0-10V hoặc 4-20mA) sang cảm biến Modbus RS485 mang lại những ưu điểm vượt trội cho tính ổn định của hệ thống:
\begin{table}[h!]
    \centering
    \renewcommand{\arraystretch}{1.3} % Tăng khoảng cách dòng cho thoáng
    \begin{tabularx}{\textwidth}{|l|X|X|} % l: căn trái cột đầu, X: tự động dãn 2 cột sau
    \hline
    \textbf{Đặc điểm} & \textbf{Cảm biến Analog} & \textbf{Cảm biến Modbus RS485}  \\
    \hline
    Cơ chế truyền & Điện áp/Dòng điện liên tục & Gói tin số (Digital Packets) \\
    \hline
    Chống nhiễu & Kém: Dễ bị nhiễu cao tần làm sai lệch giá trị điện áp đọc về & Rất tốt: Tự triệt tiêu nhiễu nhờ tín hiệu vi sai \\
    \hline
    Khoảng cách & Ngắn ($< 20$m). Dây dài gây sụt áp, sai số lớn & Xa (lên đến 1200m) mà không suy giảm chất lượng tín hiệu \\
    \hline
    Độ chính xác & Phụ thuộc vào độ phân giải ADC của vi điều khiển (ESP32 ADC thường không tuyến tính) & Dữ liệu số được chuyển đổi chính xác ngay tại cảm biến (ADC chuyên dụng bên trong) \\
    \hline
    Mở rộng & Mỗi cảm biến 1 dây kết nối riêng & Tất cả mắc song song trên 1 cặp dây Bus duy nhất \\
    \hline
    \end{tabularx}
    \caption{So sánh cảm biến Analog và Modbus RS485 trong môi trường nông nghiệp}
    \label{tab:so_sanh_sensor}
\end{table}


% \indent Hệ thống phần cứng được thiết kế để hoạt động bền bỉ trong môi trường nông nghiệp:
% \begin{itemize}
%     \item \textbf{Datalogger:} được đặt trong một hộp điện được chế tạo riêng, được thiết kế để sử dụng ngoài trời trong nông nghiệp.
%     \item \textbf{Cảm biến:} Hỗ trợ đa dạng các loại cảm biến từ cơ bản (DHT11, cảm biến mưa, ánh sáng) cho mô hình hộ gia đình đến các cảm biến chuyên dụng công nghiệp (pH, EC) cho trang trại lớn.
%     \item \textbf{Giao thức:} Sử dụng giao chuẩn RS485 cho việc kết nối cảm biến nhằm giảm thiểu nhiễu và đảm bảo truyền tin ổn định trên khoảng cách xa trong trang trại.
% \end{itemize}


\subsection{Bài toán phát hiện lỗi cảm biến trong hệ thống IoT}

\subsubsection{Lý thuyết về chất lượng dữ liệu cảm biến}
\indent Trong các hệ thống IoT và mạng cảm biến không dây (WSN), dữ liệu thu thập được thường chịu ảnh hưởng bởi các yếu tố môi trường, phần cứng xuống cấp hoặc nhiễu đường truyền. Chất lượng dữ liệu kém sẽ ảnh hưởng trực tiếp đến hiệu suất của các thuật toán học máy, đặc biệt là quá trình chọn lọc đặc trưng (Feature Selection).
\indent Để đảm bảo tính chính xác cho thuật toán Robust Feature Extraction (RFE), việc nhận diện và xử lý các lỗi cảm biến phổ biến là bước tiền xử lý bắt buộc. Dưới đây là định nghĩa và đặc điểm của ba loại lỗi thường gặp nhất: Drift, Stuck-at, và Spike.

\subsubsubsection{Lỗi trôi (Drift Fault)}
\indent \textbf{Định nghĩa:} Lỗi trôi (Drift) xảy ra khi giá trị đo được của cảm biến lệch dần khỏi giá trị thực theo thời gian một cách tuyến tính hoặc phi tuyến tính, mặc dù hiện tượng vật lý đang đo không thay đổi theo xu hướng đó.
\indent \textbf{Đặc điểm nhận diện:}
\begin{itemize}
    \item Độ lệch (offset) tăng dần theo thời gian.
    \item Thường xuất hiện do sự xuống cấp của linh kiện cảm biến (aging) hoặc thay đổi chậm của môi trường (nhiệt độ, độ ẩm ảnh hưởng đến hiệu chuẩn).
\end{itemize}
\indent Mô hình toán học: Nếu $x(t)$ là giá trị thực và $y(t)$ là giá trị đo được tại thời điểm $t$, lỗi trôi có thể được mô tả:
$$y(t) = x(t) + \delta(t)$$ Trong đó $\delta(t)$ là hàm lỗi tăng đơn điệu theo thời gian.
\indent \textbf{Tác động đến thuật toán RFE:} Lỗi Drift làm thay đổi phân phối dữ liệu. Điều này khiến RFE có thể đánh giá sai tầm quan trọng của đặc trưng (feature importance), vì mô hình có thể "học" nhầm xu hướng trôi này là một quy luật của dữ liệu thay vì loại bỏ nó.

\subsubsubsection{Lỗi Kẹt giá trị (Stuck-at Fault)}
\indent \textbf{Định nghĩa:} Lỗi kẹt (Stuck-at) là hiện tượng giá trị đầu ra của cảm biến giữ nguyên tại một hằng số bất chấp sự thay đổi của hiện tượng vật lý môi trường.
\indent \textbf{Đặc điểm nhận diện:}
\begin{itemize}
    \item Stuck-at-Zero: Giá trị kẹt tại 0.
    \item Stuck-at-Constant: Giá trị kẹt tại một số thực $C$ bất kỳ (ví dụ: giá trị max hoặc min của thang đo).
    \item Phương sai (Variance) của chuỗi dữ liệu trong khoảng thời gian lỗi bằng 0.
\end{itemize}
\indent \textbf{Tác động đến thuật toán RFE:} Lỗi Stuck-at làm mất đi tính đa dạng của dữ liệu trong khoảng thời gian lỗi, dẫn đến việc RFE không thể trích xuất các đặc trưng động học (dynamic features) như tốc độ thay đổi hay độ biến động cục
bộ, từ đó ảnh hưởng đến khả năng phân biệt giữa trạng thái bình thường và lỗi.

\subsubsubsection{Lỗi Gai nhiễu (Spike Fault)}
\indent \textbf{Định nghĩa:} Lỗi gai (Spike) là những biến động đột ngột, có biên độ lớn bất thường xuất hiện trong một khoảng thời gian rất ngắn, sau đó giá trị trở về mức bình thường.
\indent \textbf{Đặc điểm nhận diện:}
\begin{itemize}
    \item Tốc độ thay đổi (rate of change) giữa hai điểm dữ liệu liên tiếp vượt quá giới hạn vật lý mà cảm biến có thể đo đạc.
    \item Xuất hiện ngẫu nhiên và rời rạc.
\end{itemize}
\indent \textbf{Tác động đến thuật toán RFE:} Spike làm tăng phương sai ảo của dữ liệu và làm lệch các tham số thống kê (như giá trị trung bình, độ lệch chuẩn). Trong RFE, điều này có thể dẫn đến việc xếp hạng sai (mis-ranking) các đặc trưng, vì một số thuật toán đánh giá cao các đặc trưng có phương sai lớn (dù phương sai đó đến từ nhiễu).


\subsubsection{Các phương pháp tiếp cận hiện có và hạn chế}
\indent Hiện nay, bài toán phát hiện lỗi cảm biến thường được giải quyết theo ba hướng chính, tuy nhiên mỗi hướng đều tồn tại những hạn chế khi áp dụng cho các thiết bị IoT có 
tài nguyên hạn chế (Low-power IoT devices):
\begin{itemize}
    \item \textbf{Học máy cổ điển (Classic ML):} Thường gặp khó khăn trong việc nắm bắt các mẫu lỗi phức tạp hoặc phi tuyến tính trong chuỗi thời gian.
    \item \textbf{Học sâu (Deep Learning - DL):} Các mô hình như Autoencoder hay LSTM dù mạnh mẽ nhưng lại là những "hộp đen" (black-box), thiếu tính giải thích. Quan trọng hơn, chúng đòi hỏi tài nguyên tính toán và năng lượng lớn, không phù hợp để triển khai tại biên (Edge/Node).
    \item \textbf{Phương pháp dựa trên tương quan:} Hoạt động kém hiệu quả trong môi trường động và thường bỏ qua các thông tin nội tại của từng dòng dữ liệu riêng lẻ.
\end{itemize}
\indent Từ những phân tích trên, đặt ra yêu cầu về một phương pháp trích xuất đặc trưng (Feature Extraction) chuyên biệt, vừa đảm bảo độ chính xác cao, vừa tối ưu hóa tài nguyên tính toán.

\subsubsection{Cơ sở lý thuyết của phương pháp Robust Feature Extractor (RFE)}
\indent Để giải quyết bài toán trên, nghiên cứu đề xuất phương pháp Robust Feature Extractor (RFE). Thay vì tăng độ phức tạp của mô hình phân loại, RFE tập trung RFE hoạt động như một bộ lọc đa tầng biến đổi tín hiệu đầu vào $x_t$ tại thời điểm $t$ thành vector đặc trưng $F_t$. Các thành phần cốt lõi của RFE bao gồm:
\begin{itemize}
    \item \textbf{Tốc độ thay đổi (Speed of Change):} Để nắm bắt sự thay đổi đột ngột (thường gặp ở lỗi Spike), RFE tính toán đạo hàm bậc nhất rời rạc: $$v_t = x_t - x_{t-1}$$ Giá trị này đại diện cho "vận tốc" của tín hiệu.
    \item \textbf{Độ biến động cục bộ (Local Variance):} Đây là điểm cải tiến quan trọng của RFE. Thuật toán tính toán độ lệch chuẩn trượt (Rolling Standard Deviation) trên chính giá trị vận tốc $v_t$ trong cửa sổ $w$: $$\sigma_t = \sqrt{\frac{1}{w} \sum_{i=0}^{w-1} (v_{t-i} - \bar{v})^2}$$ Đặc trưng này giúp phân biệt nhiễu môi trường (biến động thấp) với lỗi cảm biến (biến động bất thường).
    \item \textbf{Xu hướng dài hạn (Smoothed Trends):} Sử dụng Trung bình động lũy thừa (EWMA) để làm mượt tín hiệu, giúp mô hình nhận diện các lỗi trôi (Drift) diễn ra từ từ: $$EWMA_t = \alpha \cdot x_t + (1-\alpha) \cdot EWMA_{t-1}$$   
    \item \textbf{Bộ nhớ thời gian (Temporal Memory):} Bổ sung các giá trị trễ (Lag features: $x_{t-1}, x_{t-2}, ...$) để cung cấp ngữ cảnh quá khứ cho mô hình phân loại tại thời điểm hiện tại.
\end{itemize}


\subsubsection{Sơ đồ Luồng xử lý tổng thể}
\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{img/Firmware/Fault Detection Process Mermain edge node.png}
    \caption{Sơ đồ luồng xử lý sơ cấp ở Edge Node}
\end{figure}
\begin{figure}
    \centering
    \includegraphics[width=0.7\textwidth]{img/Firmware/Fault Detection Process Mermain cloud node.png}
    \caption{Sơ đồ luồng xử lý phát hiện lỗi với RFE ở Backend Server}
\end{figure}


\subsection{Edge Computing}

\subsubsection{Định nghĩa}
\indent Tính toán biên (Edge Computing) là một mô hình tính toán phân tán, trong đó việc xử lý và lưu trữ dữ liệu được thực hiện ngay tại hoặc gần nguồn tạo ra dữ liệu (các thiết bị cảm biến, node mạng), thay vì dựa hoàn toàn vào một máy chủ trung tâm (Cloud/Server) ở xa.
\indent Trong ngữ cảnh của hệ thống IoT (Internet of Things), các vi điều khiển như ESP32 hoặc máy tính nhúng như Raspberry Pi đóng vai trò là các Edge Node. Chúng không chỉ đơn thuần thu thập và chuyển tiếp dữ liệu (Pass-through), mà còn có khả năng thực thi các thuật toán tính toán tại chỗ.
\subsubsection{Vai trò giảm tải cho Server}
\indent Việc chuyển dịch một phần năng lực xử lý từ Backend xuống Edge mang lại hiệu quả tối ưu hóa hệ thống dựa trên nguyên lý "lọc trước khi gửi". Cụ thể:
\begin{itemize}
    \item \textbf{Giảm băng thông mạng (Bandwidth Optimization):} Thay vì truyền tải liên tục dữ liệu thô (raw data) với tần suất cao (ví dụ: 100 mẫu/giây), thiết bị biên chỉ gửi các dữ liệu có ý nghĩa, dữ liệu đã qua nén hoặc các sự kiện (events) quan trọng.
    $$R_{send} = \alpha \times R_{raw}$$ Trong đó $R_{send}$ là lượng dữ liệu gửi đi, $R_{raw}$ là dữ liệu thu thập, và $\alpha < 1$ là tỷ lệ lọc.
    \item \textbf{Giảm độ trễ (Latency Reduction):} Các quyết định tức thời (như ngắt mạch khi phát hiện quá nhiệt/Spike) cần được thực hiện ngay tại biên (milimet giây) thay vì chờ Round-trip time (RTT) gửi lên Server xử lý rồi nhận lệnh về.
    \item \textbf{Tiết kiệm tài nguyên Server:} Server không phải tốn chu kỳ CPU để xử lý các tác vụ mức thấp như lọc nhiễu, chuẩn hóa định dạng hay loại bỏ các giá trị null/NaN. Server chỉ tập trung vào các tác vụ cao cấp như lưu trữ dài hạn, phân tích xu hướng (Trend Analysis) và chạy các thuật toán phức tạp như RFE (Rpbust Feature Extraction).
\end{itemize}

\subsubsection{Mô hình xử lý dữ liệu tại biên trong đề tài}
\indent Dựa trên lý thuyết Edge Computing, hệ thống đề xuất áp dụng quy trình xử lý 3 giai đoạn tại ESP32:
\begin{itemize}
    \item \textbf{Giai đoạn Tiền xử lý (Preprocessing):} Áp dụng các bộ lọc số (Digital Filters) đơn giản như Trung bình trượt (Moving Average) hoặc Lọc trung vị (Median Filter) để loại bỏ nhiễu trắng và làm mượt dữ liệu trước khi xử lý tiếp.
    \item \textbf{Giai đoạn Gán nhãn sơ cấp (Primary Labeling):} Thiết bị biên so sánh dữ liệu với các ngưỡng an toàn (Thresholds) hoặc kiểm tra tính liên tục của tín hiệu để gán nhãn trạng thái (Metadata). Ví dụ: Gán nhãn Normal, Warning (cảnh báo trôi - Drift), hoặc Error (lỗi kẹt - Stuck-at).
    \item \textbf{Giai đoạn Quyết định truyền tải:} Dựa trên nhãn dữ liệu, ESP32 quyết định có gửi gói tin đi hay không, hoặc gửi cảnh báo ưu tiên cao. Điều này đảm bảo Server luôn nhận được dữ liệu "sạch" hoặc dữ liệu lỗi đã được định danh rõ ràng.
\end{itemize}

\begin{table}
    \centering
    \begin{tabular}{|c|c|c|}
    \hline
    \textbf{Tiêu chí} & \textbf{Cloud Computing} & \textbf{Edge Computing}  \\
    \hline
    Dữ liệu truyền & Dữ liệu thô & Dữ liệu đã qua xử lý sơ bộ  \\
    \hline
    Băng thông & Cao & Thấp  \\
    \hline
    Phản hồi & Độ trễ cao &  Độ trễ thấp \\
    \hline
    Nhiệm vụ server & Xử lý chuyên sâu và sơ cấp & Chỉ xử lý chuyên sâu  \\
    \hline
    Xử lý nhiễu & Nhiễu được gửi & Nhiễu bị loại bỏ sơ bộ tại nguồn  \\
    \hline
    \end{tabular}
    \caption{So sánh Cloud Computing và Edge Computing trong hệ thống IoT}
\end{table}